快速排序（Quick Sort）是一种分治法的排序算法，通过选定一个"基准"元素，将数组分成两个子数组，一个子数组比基准元素小，另一个子数组比基准元素大。然后递归地对这两个子数组进行排序，最终实现整个数组的排序。
算法步骤：
选择基准元素（pivot）：通常选取数组的第一个元素、最后一个元素、随机元素，或中位数。
分区操作：通过基准元素将数组分成两部分，其中一部分所有元素都小于基准元素，另一部分所有元素都大于基准元素。
递归排序：对基准元素左边和右边的子数组进行递归排序。
快速排序的 Python 代码实现：
pythonCopy Code
def quicksort(arr):
    # 如果数组长度小于等于1，直接返回
    if len(arr) <= 1:
        return arr
    # 选择基准元素，这里选择最后一个元素作为基准
    pivot = arr[-1]
    left = [x for x in arr[:-1] if x <= pivot]
    right = [x for x in arr[:-1] if x > pivot]
    
    # 递归排序并合并结果
    return quicksort(left) + [pivot] + quicksort(right)

# 测试示例
arr = [10, 7, 8, 9, 1, 5]
sorted_arr = quicksort(arr)
print("排序后的数组:", sorted_arr)
示例：
输入：[10, 7, 8, 9, 1, 5]
输出：[1, 5, 7, 8, 9, 10]
总轮数 K 的 K 值：
在快速排序中，总轮数 K 的 K 值可以理解为递归调用的深度或者分区的次数。对于每一轮分区，我们都会将数组分为两部分并递归地对每个子部分进行排序。最坏的情况下（每次分割不平衡），递归的深度是 O(n)，但是平均情况下递归的深度是 O(log n)，因此 K 值的最大值为 O(n)，平均值为 O(log n)。
总时间复杂度：
最佳情况：O(n log n)，发生在每次分区后都能把数组均匀分成两部分。
最坏情况：O(n²)，发生在每次选取的基准都是最大或最小元素（即数组已经有序或逆序）。
平均情况：O(n log n)，这是快速排序最常见的情况。
空间复杂度：
快速排序的空间复杂度主要由递归栈的深度决定：
空间复杂度：O(log n)，在最好的情况下，递归深度为 log n；在最坏的情况下，空间复杂度为 O(n)，当每次分割都非常不平衡时。
快速排序的优缺点：
优点：
时间效率高：对于大多数情况，时间复杂度为 O(n log n)，非常高效，尤其适用于大数据集。
原地排序：快速排序是一种原地排序算法，节省空间，不需要额外的内存（除了递归栈空间）。
缺点：
最坏情况下的性能差：如果每次分割选择的基准元素很差（例如已经排好序的数组），那么时间复杂度会退化到 O(n²)。
不稳定排序：快速排序不是稳定的排序算法，即相等的元素可能会改变相对顺序。
递归栈深度：在某些极端情况下（如已经有序的数组），递归栈的深度会很大，可能会导致栈溢出。
通过合理选择基准元素和优化分区策略（比如三数取中法），可以提高快速排序的性能。
