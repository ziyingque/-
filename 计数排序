计数排序是一种非比较型排序算法，它通过统计输入数据中每个元素的出现次数，然后将元素按照出现次数排序。计数排序适用于排序范围有限且元素可以重复的情况。
算法步骤
确定数据范围：确定输入数据中的最大值和最小值，用于确定计数数组的大小。
创建计数数组：创建一个计数数组，其中的每个元素对应数据范围内的一个数值，数组的值表示该数值在原数组中出现的次数。
统计每个元素的出现次数：遍历原始数据，对每个元素计数，存储到计数数组中。
累加计数数组：对计数数组进行累加处理，使得每个元素的值表示该元素在排序后的最终位置。
构建排序后的数组：根据累加后的计数数组，将元素放入正确的位置。
Python代码实现
pythonCopy Code
def counting_sort(arr):
    # 1. 找出输入数组中的最大值和最小值
    if len(arr) == 0:
        return arr
    
    min_val = min(arr)
    max_val = max(arr)
    
    # 2. 创建计数数组，大小为 max_val - min_val + 1
    count = [0] * (max_val - min_val + 1)
    
    # 3. 统计每个元素的出现次数
    for num in arr:
        count[num - min_val] += 1
    
    # 4. 累加计数数组
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    
    # 5. 创建排序后的结果数组
    sorted_arr = [0] * len(arr)
    
    # 6. 将元素放入排序后的数组
    for num in reversed(arr):
        index = count[num - min_val] - 1
        sorted_arr[index] = num
        count[num - min_val] -= 1
    
    return sorted_arr

# 示例
arr = [4, 2, 2, 8, 3, 3, 1]
sorted_arr = counting_sort(arr)
print("Sorted Array:", sorted_arr)
示例
假设输入数组为：
pythonCopy Code
arr = [4, 2, 2, 8, 3, 3, 1]
运行计数排序后：
找出最大值8和最小值1。
创建计数数组，记录每个元素的出现次数。
累加计数数组，使其表示每个元素在最终排序中的位置。
按照累加后的计数数组将元素放入正确的位置。
输出为：
pythonCopy Code
Sorted Array: [1, 2, 2, 3, 3, 4, 8]
总轮数K的K值
计数排序的总轮数（K值）通常指算法中涉及的循环次数。在计数排序中：
统计每个元素出现次数：对数组 arr 进行一次遍历，时间复杂度是 O(n)，其中 n 是数组的长度。
累加计数数组：对计数数组 count 进行一次遍历，时间复杂度是 O(k)，其中 k 是数据范围（max_val - min_val + 1）。
构建排序后的数组：再次遍历原始数组，时间复杂度是 O(n)。
因此，计数排序的总时间复杂度为 O(n + k)，其中 n 是输入数据的元素个数，k 是数据范围。
时间复杂度
最优情况：O(n + k)，当数据范围 k 与数据量 n 较小且相对均匀分布时，计数排序是非常高效的。
最坏情况：O(n + k)，即使数据不均匀分布，时间复杂度也是 O(n + k)，但如果 k 较大（数据范围大），则可能导致较慢的性能。
空间复杂度
空间复杂度：O(n + k)，其中 n 是输入数组的大小，k 是数据范围。需要一个大小为 k 的计数数组来存储每个元素的出现次数，并且需要额外的空间来存储排序后的数组。
优缺点
优点
时间复杂度低：对于数据范围有限的情况下，计数排序可以在 O(n + k) 时间内完成排序，效率很高。
适用于特定场景：特别适合排序整型数据或者可以用整数表示的数据，且数据范围不大。
稳定性：计数排序是稳定的排序算法，即相同元素的相对顺序不会改变。
缺点
空间复杂度高：当数据范围很大时，计数数组的大小 k 也会变得很大，导致占用大量内存。
不适用于浮动数据或非整数数据：如果输入数据的范围非常大，或者是浮动数据，使用计数排序就不太合适。
依赖数据范围：当数据范围 k 远大于元素个数 n 时，计数排序的效率会受到影响，变得不适用。
